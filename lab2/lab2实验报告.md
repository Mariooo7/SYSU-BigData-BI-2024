# 实验报告 关联规则挖掘

# 数据集：Samples/data/Transactions  

## 0. 引言

- 本次实验主要对RapidMiner自带的样本交易数据进行关联规则挖掘，使用到课上所讲的FP-growth算法，挖掘数据集中的频繁项和关联规则，且尝试了考虑特定数量商品间存在关联规则的情况
- 其后，我将数据集导出到本地的csv文件，并利用Python的`mxltend`库完成了Apriori和FP-growth算法的实现，可视化了两种算法在该数据集上指定不同最小支持度的运行时间



## 1. 实验结果与问题讨论

<img src=".\lab2_v0.png" style="zoom: 80%;" />

### 1.1 读取数据与数据集理解

![image-20241026201911373](.\lab2实验报告.assets\image-20241026201911373.png)

#### 1.1.1 通过点击拖拽数据集/Retrieve算子/Read CSV算子读取数据

​	![image-20241026202116863](.\lab2实验报告.assets\image-20241026202116863.png)

> 填写或选择正确的文件地址

---

读取后可以输出查看数据集的基本情况与描述性统计信息，如图：

![image-20241026202344082](.\lab2实验报告.assets\image-20241026202344082.png)

1. 数据集由三列构成，分别是顾客的ID、产品的ID以及（单次购买记录中）产品的数量

2. 数据集不含有任何缺失值和明显异常值

3. 三列变量类型都是Integer（整数）

4. 顾客ID的最大值比总行数小很多，推测加观察易发现该数据集中同一顾客ID的不同产品的购买记录分散在不同行中需要整理汇总。

5. 数据集的用途是用来挖掘商品之间的关联规则，即哪些商品的销售是由关联关系的，以制定更好的促销或生产策略



>  **此处会产生一个问题**：
>
> ==在本实验的关联规则挖掘中，Amount是否需要被考虑？==
>
> ==即，我们应当只关注商品与商品之间的关联，还是要再多加考虑特定数量商品之间存在关联？==
>
> **为此我分两种思路完成实验**:
>
> 1. 只考虑商品与商品之间的关联规则，即弃置[Amount]
> 2. 考虑特定数量商品间存在联系，即以[Product ID*Amount]替代[Product ID]，其他步骤相同
>
> 
>
> 经过实验，发现后者在本实验中没有有价值的产出，具体原因见**1.5 第二种思路**，下文以第一种思路进行



#### 1.1.2 转化变量类型

为了符合后续分组合并、算法输入的变量类型要求，此处需将数值型变量转化为Polynominal类型，具体参数设置如下图：

![image-20241026204842325](.\lab2实验报告.assets\image-20241026204842325.png)

#### 1.1.3 删除冗余变量

使用Select Attributes算子-exclude attributes剔除冗余变量Amount

​	![image-20241026205035331](.\lab2实验报告.assets\image-20241026205035331.png)



---



### 1.2   规范事务表格式

![image-20241026205332343](.\lab2实验报告.assets\image-20241026205332343.png)

#### 1.2.1 汇总购买记录

使用Aggregate算子按变量分组和对变量进行函数操作

![image-20241026205645178](.\lab2实验报告.assets\image-20241026205645178.png)

**第一步**：按Customer ID分组

![image-20241026205735845](.\lab2实验报告.assets\image-20241026205735845.png)

**第二步**：对Product ID变量使用concatenation函数，将相同分组（Customer ID）的Product ID汇总连接在同一列

![image-20241026210050684](.\lab2实验报告.assets\image-20241026210050684.png)	

**第三步**：将存储了汇总数据的列重命名为Products



#### 1.2.3 设置id

![image-20241026210258818](.\lab2实验报告.assets\image-20241026210258818.png)	

使用Set Role算子，将Customer ID的role设为id

---



### 1.3 FP-growth算法挖掘频繁项集和关联规则

![image-20241026210613309](.\lab2实验报告.assets\image-20241026210613309.png)

- 使用FP-growth算子可以便捷地进行算法运算，按指定最小支持度生成频繁项集
- 再通过Create Association算子依据指定的最小置信度/提升度生成关联规则

#### 1.3.1 参数设置

- 最小支持度先尝试默认的 0.005

- 为了避免产品自身的流行性/泛用性带来的置信度不可靠问题，本实验采用提升度（lift）作为选取频繁项创建关联规则的依据

  > 因为 lift$ > 1$才说明商品的购买之间有正向的影响，所以考虑先设置min lift value为2

- 不对关联规则中商品的数量设限，不用更改相关参数

具体设置如图：

![image-20241026211636258](.\lab2实验报告.assets\image-20241026211636258.png)![image-20241026211658214](.\lab2实验报告.assets\image-20241026211658214.png)



#### 1.3.2 调整参数

![image-20241026211842452](.\lab2实验报告.assets\image-20241026211842452.png)

观察第一次输出的结果，从频繁项集的输出结果可见：

1. **228个频繁项**，其中包含至多两件商品的组合
2. **最高支持度达到0.036**

![image-20241026212202744](.\lab2实验报告.assets\image-20241026212202744.png)

![image-20241026212331397](.\lab2实验报告.assets\image-20241026212331397.png)	（部分关联规则结果)

从关联规则的输出结果可见：

1. 获取了很多条关联规则，对于结果来说可能**过多**了，需要再提高最小支持度
2. 按支持度降序排序，发现有四条支持度为**0.007**，其余皆为0.005
3. 输出的关联规则的提升度都**较高**



**综上**

仅需调高最小支持度，将其设为0.006

![image-20241026212858760](.\lab2实验报告.assets\image-20241026212858760.png)	

输出结果：

1. 频繁项集（部分）：

   ![image-20241026213010073](.\lab2实验报告.assets\image-20241026213010073.png)

2. 关联规则：

   ![image-20241026213540816](.\lab2实验报告.assets\image-20241026213540816.png)

   ![image-20241026213040508](.\lab2实验报告.assets\image-20241026213040508.png)

---

### 1.4 结果解释

商品ID为79、1和151、18的商品之间有较强的关联规则，购买其中一件商品时同组的另一件商品被购买的可能性会大大提升



---

### 1.5 第二种思路

![image-20241026213718922](.\lab2实验报告.assets\image-20241026213718922.png)

与第一种思路的唯一差异在于此处增加一个Generate Concatenation算子用于生成[Product ID*Amount]

**参数设置**：

![image-20241026213858226](.\lab2实验报告.assets\image-20241026213858226.png)

其后需记得将原来的Product ID 和 Amount在下一步剔除，其余操作基本一致



**观察试运行的结果**：

设置min support value = 0.005或0.004时

无关联规则发现

再调低到min support value = 0.003

**频繁项集**：

![image-20241026214343340](.\lab2实验报告.assets\image-20241026214343340.png)

**关联规则**：

![image-20241026214409705](.\lab2实验报告.assets\image-20241026214409705.png)



但因为，对于本实验的事务数(593)，0.003作为最小支持度太小(1/593 = 0.0016)，所以该结果在本实验中没有意义，即不能挖掘出特定数量商品之间的关联规则。



---

### 1.6 Python实现&两种算法的比较

#### 1.6.1 获取数据集

![image-20241026215136182](.\lab2实验报告.assets\image-20241026215136182.png)

使用图示流程将数据集写入csv文件并存放到指定目录

---

#### 1.6.2 算法实现与可视化过程 

##### 必要的库

1. pandas：数据操作
2. mlxtend：提供算法函数
3. matplotlib：可视化工具
4. time：计时

##### 1. 数据理解（没什么内容，与前文重复，略）

<img src=".\lab2实验报告.assets\image-20241026220633466.png" alt="image-20241026220633466" style="zoom: 33%;" />	<img src=".\lab2实验报告.assets\image-20241026220716294.png" alt="image-20241026220716294" style="zoom: 50%;" />

##### 2. 借助mlxtend库实现两种算法

mlxtend的全称为'Machine Learning Library Extensions', 其中包含了用于关联规则挖掘的算法函数

![image-20241026221029050](.\lab2实验报告.assets\image-20241026221029050.png)

mlxtend.frequent_patterns包含了关联规则挖掘有关的算法和关联规则函数

为使数据集可用于函数的输入以及内容的清晰可读，先对Product ID进行前缀为'Product'的独热编码

---

![image-20241026221316484](.\lab2实验报告.assets\image-20241026221316484.png)

其后使用类似上述Aggregate算子的操作，以Customer ID分组，而`.any()`会令所有加总后的Product_id的非零值为True，零为False

![image-20241026221556811](.\lab2实验报告.assets\image-20241026221556811.png)

观察处理好的数据集group_data的head

---

接下来只需要使用对应算法函数，并设置已经调整好的参数就能得到期望的结果，理论上两种算法的输出应该相同：

![image-20241026221821027](.\lab2实验报告.assets\image-20241026221821027.png)

![image-20241026221847067](.\lab2实验报告.assets\image-20241026221847067.png)

确实一样，没问题

---

##### 3. 比较两种算法的运行时间

![image-20241026222030421](.\lab2实验报告.assets\image-20241026222030421.png)

定义时间测量的函数，并计算两种算法在本实验数据集中的运行时间：

- `def measure_time(func, min_support):`在Python中函数可以被作为(其他)函数的输入

- `for i in range(100):`本实验数据集较小，重复运行以获得稳定的运行时间
- `min_support_values = [0.003,0.004,0.005,0.006,0.007,0.008,0.009,0.01]`根据对数据集的了解拟定

![image-20241026222341564](.\lab2实验报告.assets\image-20241026222341564.png)

<img src=".\lab2实验报告.assets\image-20241026222407908.png" alt="image-20241026222407908" style="zoom:50%;" />

由上图可见Apriori算法在本实验中的运行效率的确低于FP-growth算法，尤其在最小支持度很低的时候，因为此时在本实验中该算法需要遍历数据集三遍以获取频繁三项集



## 2. 实验心得

1. 感觉目前所学习的关联规则挖掘缺乏考虑复杂商品数量组合的"权重"设计，只能考虑品类之间的关联

2. 最小支持度的调节需要观察试错和经验结合

3. 在后续Python实现的过程中我尝试了‘手搓’两种算法，但在网上学习和搜集资料时发现这两种算法在最先的基础上有很多优化方法，其中对Apriori的优化主要集中在迭代获取频繁项集的方法上，通过更优、更具效率的子集获取方式减少迭代次数，在一些数据集上甚至能获得比FP-growth更优的运行效率（如下图所示，参考来自：[blackAndrechen/data_mine: Apriori and fp-growth implement of python](https://github.com/blackAndrechen/data_mine)），而FP-growth的优化却见得不多

   ![](.\lab2实验报告.assets\improve_2.png)

4. 关联规则挖掘是一项重要且实用的技术和方法